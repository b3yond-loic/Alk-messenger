# Premiere essai: Messagerie tchat/ system de token.

# à installer: pip install fastapi uvicorn sqlalchemy passlib[bcrypt] python-jose[cryptography]
#              pip install PyJWT python-multipart
# Lancer le serveur: uvicorn main:app --reload

from fastapi import FastAPI, HTTPException, Depends
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from pydantic import BaseModel
from passlib.context import CryptContext
from sqlalchemy import create_engine, Column, Integer, String, Text, ForeignKey, DateTime, func
from sqlalchemy.orm import declarative_base, sessionmaker, relationship
import jwt
from datetime import datetime, timedelta

# -----------------------
# Config & DB
# -----------------------
DATABASE_URL = "sqlite:///./alkemia.db"  # PostgreSQL plus tard
SECRET_KEY = "CHANGE_ME_SECRET"
ALGORITHM = "HS256"

engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
Base = declarative_base()
SessionLocal = sessionmaker(bind=engine)

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")

# -----------------------
# Models SQLAlchemy
# -----------------------
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False)
    password_hash = Column(String, nullable=False)
    display_name = Column(String, default="Anon")
    tokens = Column(Integer, default=0)
    created_at = Column(DateTime, default=func.now())

class Message(Base):
    __tablename__ = "messages"
    id = Column(Integer, primary_key=True)
    sender_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    content = Column(Text, nullable=False)
    created_at = Column(DateTime, default=func.now())

class Transaction(Base):
    __tablename__ = "transactions"
    id = Column(Integer, primary_key=True)
    sender_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    receiver_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    amount = Column(Integer, nullable=False)
    created_at = Column(DateTime, default=func.now())

Base.metadata.create_all(bind=engine)

# -----------------------
# Schemas Pydantic
# -----------------------
class UserCreate(BaseModel):
    email: str
    password: str
    display_name: str

class MessageCreate(BaseModel):
    content: str

class TransactionCreate(BaseModel):
    receiver_id: int
    amount: int

# -----------------------
# Utils
# -----------------------
def create_access_token(data: dict, expires_delta: timedelta = timedelta(hours=1)):
    to_encode = data.copy()
    expire = datetime.utcnow() + expires_delta
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def get_current_user(token: str = Depends(oauth2_scheme), db=Depends(get_db)):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user = db.query(User).filter(User.id == payload["sub"]).first()
    except:
        raise HTTPException(status_code=401, detail="Invalid authentication")
    return user

# -----------------------
# FastAPI app
# -----------------------
app = FastAPI(title="Alkemy MVP")

# ---- Auth ----
@app.post("/signup")
def signup(user: UserCreate, db: SessionLocal = Depends(get_db)):
    if db.query(User).filter(User.email == user.email).first():
        raise HTTPException(status_code=400, detail="Email déjà utilisé")
    hashed_pw = pwd_context.hash(user.password)
    db_user = User(email=user.email, password_hash=hashed_pw, display_name=user.display_name)
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return {"message": "Utilisateur créé", "user_id": db_user.id}

@app.post("/login")
def login(form_data: OAuth2PasswordRequestForm = Depends(), db: SessionLocal = Depends(get_db)):
    user = db.query(User).filter(User.email == form_data.username).first()
    if not user or not pwd_context.verify(form_data.password, user.password_hash):
        raise HTTPException(status_code=401, detail="Identifiants invalides")
    token = create_access_token({"sub": user.id})
    return {"access_token": token, "token_type": "bearer"}

# ---- Messages ----
@app.post("/messages")
def send_message(msg: MessageCreate, current_user: User = Depends(get_current_user), db: SessionLocal = Depends(get_db)):
    db_msg = Message(sender_id=current_user.id, content=msg.content)
    db.add(db_msg)
    db.commit()
    db.refresh(db_msg)
    return {"message": "Envoyé", "id": db_msg.id, "content": db_msg.content}

@app.get("/messages")
def get_messages(db: SessionLocal = Depends(get_db)):
    msgs = db.query(Message).order_by(Message.created_at.desc()).limit(20).all()
    return [{"id": m.id, "sender": m.sender_id, "content": m.content, "date": m.created_at} for m in msgs]

# ---- Tokens ----
@app.post("/tokens/send")
def send_tokens(data: TransactionCreate, current_user: User = Depends(get_current_user), db: SessionLocal = Depends(get_db)):
    if current_user.tokens < data.amount:
        raise HTTPException(status_code=400, detail="Solde insuffisant")
    receiver = db.query(User).filter(User.id == data.receiver_id).first()
    if not receiver:
        raise HTTPException(status_code=404, detail="Destinataire introuvable")

    current_user.tokens -= data.amount
    receiver.tokens += data.amount
    tx = Transaction(sender_id=current_user.id, receiver_id=receiver.id, amount=data.amount)
    db.add(tx)
    db.commit()
    return {"message": f"{data.amount} tokens envoyés à {receiver.display_name}"}

@app.post("/tokens/buy")
def buy_tokens(current_user: User = Depends(get_current_user), db: SessionLocal = Depends(get_db)):
    # Simulation achat : +100 tokens
    current_user.tokens += 100
    db.commit()
    return {"message": "100 tokens ajoutés", "balance": current_user.tokens}

@app.get("/me")
def get_profile(current_user: User = Depends(get_current_user)):
    return {"id": current_user.id, "email": current_user.email, "tokens": current_user.tokens}
